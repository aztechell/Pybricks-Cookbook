# Async / await в Pybricks

## Зачем вообще нужен `await`

Pybricks — однопоточная среда. Код выполняется **строго последовательно**, если не используется `async/await`.

`await` — это механизм **кооперативной многозадачности**:
- нет потоков
- нет параллельного выполнения
- есть добровольная передача управления

Код сам сообщает системе:  
> «Я сейчас жду — можешь выполнить что‑то другое».

---

## Обычное выполнение (без async)

Последовательный код:

```
функция A:
  шаг 1
  шаг 2
  шаг 3

функция B:
  шаг 1
  шаг 2
  шаг 3
```

Пока `A` не закончится, `B` **не начнётся**.  
Любой `wait()` блокирует всё.

---

## Async‑функции

Async‑функция объявляется так:

```python
async def task():
    ...
```

Такая функция **не выполняется напрямую**.  
Она должна быть:
- либо `await`‑нута
- либо запущена через `run_task()` или `multitask()`

---

## Что делает `await`

`await`:
- **останавливает текущую задачу**
- **возвращает управление event loop**
- разрешает выполниться другим задачам

Важно:
- `await` не ускоряет код
- `await` не создаёт поток
- `await` — точка переключения

---

## Event loop в Pybricks

В Pybricks есть один event loop:

- он хранит список активных задач
- он выполняет задачи до первого `await`
- он переключается только в `await`

Если задача **не делает await**, она блокирует всё.

---

## Пример чередования задач

```
Task A:
  шаг 1
  await wait(10)
  шаг 2

Task B:
  шаг 1
  await wait(0)
  шаг 2
```

Выполнение:

1. A выполняется до `await`
2. A останавливается
3. B выполняется
4. B останавливается
5. Event loop возвращается к A

Это **чередование**, а не параллельность.

---

## `wait()` и `await wait()`

`wait(ms)` без `await`:
- блокирует всё

`await wait(ms)`:
- приостанавливает только текущую задачу
- даёт другим задачам выполняться

`await wait(0)`:
- немедленно отдаёт управление
- используется для частого переключения

---

## run_task()

```python
run_task(main())
```

- запускает **одну** async‑функцию
- блокирует основной поток
- **нельзя вызывать вложенно**

`run_task()` всегда используется **один раз**.

---

## multitask()

```python
await multitask(task1(), task2())
```

Позволяет:
- запускать несколько async‑задач
- выполнять их кооперативно

Параметры:
- `race=True` — завершить всё, когда первая задача закончится

---

## Что async НЕ делает

Async в Pybricks:

❌ не делает код быстрее  
❌ не даёт параллелизм  
❌ не гарантирует real‑time  
❌ не заменяет таймеры и IRQ  

---

## Когда async оправдан

Async полезен, когда есть:
- несколько независимых циклов
- сенсоры + управление + логика
- состояния, а не линейный сценарий

Async — это **архитектурный инструмент**, а не оптимизация.

---

## Главный принцип

> Если код не делает `await`, он блокирует всё.

Хорошая async‑задача:
- короткая
- часто делает `await`
- не содержит долгих вычислений

---

## Итог

`await` в Pybricks — это:
- добровольная пауза
- кооперативная многозадачность
- способ держать систему управляемой

Это не магия.  
Это дисциплина.
